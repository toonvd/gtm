#!/bin/bash

# Copyright (C) 2010 Daniel Garcia Moreno <dani@danigm.net>
# Copyright (C) 2010 Eduardo Robles Elvira <edulix@wadobo.com>
# Copyright (C) 2013 Alexey Alekhin <alexey.alekhin@me.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 3 or any later version, incorporated
# herein by reference.

VERSION="0.9.4"

export GIT_NOTES_DISPLAY_REF="refs/notes/timetracker"

# Text color variables
tund=$(tput sgr 0 1) # underline
tbld=$(tput bold)    # bold
tred=$(tput setaf 1) # red
tgrn=$(tput setaf 2) # green
tyel=$(tput setaf 3) # yellow
tblu=$(tput setaf 4) # blue
tgry=$(tput setaf 8) # gray
trst=$(tput sgr0)    # reset
# Surroungings
txtsurround() { printf "${1}${2}${trst}" "${@:3}"; }
red()    { txtsurround $tred "$@"; }
green()  { txtsurround $tgrn "$@"; }
yellow() { txtsurround $tyel "$@"; }
blue()   { txtsurround $tblu "$@"; }
gray()   { txtsurround $tgry "$@"; }
bold()   { txtsurround $tbld "$@"; }
underline() { txtsurround $tund "$@"; }

# some common printing functions
err() {
    red "$1\n"
    [ "$2" ] && echo "$2"
    exit 1
}
confirm() {
    echo "$1"
    read -n 1 -p "[press any key to continue]"
    # now go up one line and erase it
    tput cuu1 && tput el
    echo
}
overview() {
    echo `bold "Operation overview:"`
    for s in "$@"; do
        echo $s
    done
    read -n 1 -p "[review steps and press any key to continue]"
    local n=$(( $# + 2 ))
    until (( n == 0 )); do
        tput cuu1 && tput el
        n=$(( n - 1 ))
    done
}
failed() {
    local result=$1
    local msg=${2:-"Previous step has failed"}
    if (( $result != 0 )); then
        echo `red "$msg"`
        local decision
        read -p "[enter 'continue' to proceed or anything else to stop]: " decision
            tput cuu1 && tput el
        [ "$decision" != "continue" ] && exit 0
    fi
}

### USAGE

general_help="
gtm v$VERSION - git task/time manager (c) Alexey Alekhin

`bold 'Usage'`: `blue 'gtm command [options]'`

`bold 'General commands'`:
    `green 'usage|-h|--help|help'`  -- show this mesage
    `green 'version|-v|--version'`  -- show current version
    `green init`                  -- set up gtm configuration (hooks and git-config); run this in every new repository
    `green repo`                  -- (path to) the repository of the current running timer

`bold 'Timer commands'`:
    <[+-]time>            -- set/add/subtract spent time (see help for the time formats)
    `green start` <[+-]time>      -- start timer (setting time if given)
    `green stop` <[+-]time>       -- pause timer (setting time if given)
    `green status` [flags]        -- show current timer state
    `green steal`                 -- steal all time from another task (master by default) and move it to the current task
          [-i <issue>]       pick task by issue number
       or [-b <branch>]      pick task by branch name

`bold 'Information commands'`:
    `green list`                  -- list all tasks with issue numbers and timers information
    `green tree`                  -- prints the tree of branches with respect to their base branches
    `green log`                   -- same as git-log but with human-format time notes
    `green summary`               -- print summary of spent time by authors
    `green report` [options]      -- print list of commits with time information and summary
    `green weekly-report`         -- print reports grouped by weeks for a set of projects
      [<first>] [<last>]     week diapason (just current week by default)
      --projects <file>      file with projects mapping config (see help for details)

`bold 'Commits related commands'`:
    `green undo`   [<number>]     -- (soft) reset given number of commits (1 by default) and return their time
    `green amend`  [<commit_sha>] -- set currently spent time to the given commit (HEAD by default)
    `green note`   \"<message>\"  -- alias for empty commit with given message
    `green delete` [<commit_sha>] -- delete timer note of given commit (HEAD by default)
    `green merge`  [<remote>]     -- merge timetracker notes from remote branch (origin by default)
    `green push`                  -- pushes current branch (setting upstream) and pushes timetracker notes

`bold 'Task commands'`:
    `green task` <name> <options> -- create new task
    `green connect` [options]     -- transform bound issue to pull-request if possible
    `green info` [-w]             -- show info about task branch, timer and the bound issue
    `green comment` [-w]          -- comment issue bound to the current task
    `green switch` <number>       -- switch between tasks by issue number
    `green close`                 -- close current task

    Use `blue 'gtm help <command>'` for more information about options and behaviour
"
function show_help {
    (( $# == 0 )) && echo "$general_help" && exit 0
    case $1 in
        status|set|add|start|stop|amend|task|connect|info|comment|switch|close|report|weekly-report|push)
            gtm $1 --help
        ;;
        *)
            err "No help entry for '$1'"
        ;;
    esac
}


### HOOKS

function pre_commit_hook() {
echo '#!/bin/bash
# check if the timer is not zero
time=$(gtm status --seconds)
if (( $time == 0 )); then
    echo "`tput setaf 1`You forgot to set the timer!`tput sgr0` See 'gtm help amend'"
fi'
}


function post_commit_hook() {
echo '#!/bin/bash

running=$(git config timetracker.start)
gtm stop > /dev/null
current_branch=$(git rev-parse --abbrev-ref HEAD)
spent=$(git config branch.$current_branch.spent)
git config --unset branch.$current_branch.spent

if (( ${spent:-0} > 0 )); then
    git notes --ref timetracker add -m "Time-spent: $spent"
    [ $running ] && gtm start > /dev/null
    echo "Time-spent: $(gtm human-time $spent)"
fi'
}

function post_merge_hook() {
echo '#!/bin/bash

gitdir=$(git rev-parse --git-dir)
for remote in $gitdir/refs/notes/remotes/*; do
    gtm merge "$(basename $remote)"
done'
}

function post_checkout_hook() {
echo '#!/bin/bash

if (( $3 == 1 )) # if branch is switched
then
    old_branch=$(git config timetracker.branch)
    start=$(git config timetracker.start)
    spent=$(git config branch.$old_branch.spent)
    now=$(date +%s)

    # save state of old branch
    [ $start ] && spent=$(( $spent + $now - $start ))
    git config branch.$old_branch.spent ${spent:-0}
    git config --unset timetracker.start

    # use new branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git config timetracker.branch $current_branch
    [ "$start" ] && gtm start &> /dev/null

    gtm list
fi'
}

### COMMON FUNCTIONS

function human_time() {
    local s=${1:-0}
    s=${s#-} # removing - sign
    local m=0
    while (( $s >= 60 )); do
        m=$(( $m + $s / 60 ))
        s=$(( $s % 60 ))
    done
    local h=0
    while (( $m >= 60 )); do
        h=$(( $h + $m / 60 ))
        m=$(( $m % 60 ))
    done

    if [ "$2" == "--short" ]; then
        (( $h < 10 )) && hh="0$h:" || hh="$h:"
        (( $m < 10 )) && mm="0$m:" || mm="$m:"
        (( $s < 10 )) && ss="0$s"  || ss="$s"
        echo "$hh$mm$ss"
    else
        (( $h > 0 )) && printf "%2d hour"    $h
        (( $h > 1 )) && printf "s " || printf "  "

        (( $m > 0 )) && printf "%2d minute"  $m
        (( $m > 1 )) && printf "s " || printf "  "

        (( $s > 0 )) || (( $h + $m + $s == 0 )) && \
                        printf "%2d second" $s && \
            (( $s != 1 )) && printf "s" || printf " "

        echo
    fi
}

# given the number of week and optionally year, returns the date of it's week monday
function monday() {
    local week=$1
    local year=${2:-$(date +%Y)}
    local fst_week_day=$(date -d $year-01-01 +%u)

    date -d "$year-01-01 -$((fst_week_day - 1)) day +$(($week - 1)) week" +%F
}

# the same as monay function +6 days
function sunday() {
    date -d "$(monday $*) +6 day" +%F
}

function start_date() { git config timetracker.start; }
function start_from_now() { git config timetracker.start $(date +%s); }

function spent_get() {
    local branch=${1:-$(current_branch)}
    local spent=$(git config branch.$branch.spent)
    [ ! $spent ] && git config branch.$branch.spent 0
    echo ${spent:-0}
}
function spent_set() {
    local branch=${2:-$(current_branch)}
    git config branch.$branch.spent $1
}

function current_branch() { git rev-parse --abbrev-ref HEAD; }

function current_time() {
    local start_date=$(start_date)
    local current_date=$(date +%s)
    local spent=$(spent_get)
    [ $start_date ] && spent=$(( $spent + $current_date - $start_date ))
    echo $spent
}

function user_time_dedication() {
    local alltimes=$(git log --author="$1" --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')

    local total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done

    echo $total
}

function on_status() { [ $(start_date) ] && green "  [on]" || red " [off]"; }

function gitdir() { echo "$(git rev-parse --git-dir 2> /dev/null)"; }
function gitroot() { echo "$(git rev-parse --show-toplevel 2> /dev/null)"; }

### SUBCOMMANDS
function gtm_addf() {
    local path=$1
    git add $path 2> /dev/null
}

function gtm_commit() {
    local issue_number=$(git config branch.$(git rev-parse --abbrev-ref HEAD).issue)
    local issue_details=$(ghi show $issue_number | head -n 1)
    git commit -m "$issue_details" 2> /dev/null
}

function gtm_start() {
    local help_msg="
`bold Usage`: `blue 'gtm start'` `green '[<[+-]time>]'`

Starts the timer and sets it's value if it's given (see `blue 'gtm help set'`)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    [ ! $(gitdir) ] && err "It's not a git root directory!"

    [ "$1" ] && gtm_set $1 > /dev/null

    local running_repo=$(git config --global timetracker.repo)
    local current_repo=$(gitroot)
    if [ "$running_repo" == "$current_repo" ] && [ $(start_date) ]; then
        gtm_status
    else
        [ "$running_repo" ] && [ "$running_repo" != "$current_repo" ] && gtm_stop
        start_from_now
        spent_get > /dev/null
        git config --global timetracker.repo "$current_repo"
        echo "`gtm_status --no-label` `green [started]`"
    fi
}

function gtm_stop() {
    local help_msg="
`bold Usage`: `blue 'gtm start'` `green '[<[+-]time>]'`

Stops the timer and sets it's value if it's given (see `blue 'gtm help set'`)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local running_repo=$(git config --global timetracker.repo)
    if [ ! "$running_repo" ]; then
        [ ! $(gitdir) ] && err "No running timers"
        gtm_status
    else
        local current_dir=$(pwd -P)
        local current_repo=$(gitroot)
        [ "$running_repo" != "$current_repo" ] && cd "$running_repo"
        spent_set $(current_time)
        git config --unset timetracker.start
        [ "$1" ] && gtm_set $1 > /dev/null

        printf "`gtm_status --no-label` `red [paused]`"
        [ "$running_repo" != "$current_repo" ] && echo " in `blue [$running_repo]`" || echo

        [ "$running_repo" != "$current_repo" ] && cd "$current_dir"
        git config --global --remove-section timetracker &> /dev/null
    fi
}

function gtm_status() {
    local help_msg="
`bold Usage`: `blue 'gtm status'` `green '[<flags>]'`

Shows current timer state. Optional flags are
 `bold '*'` `green '-g|--global'` - show status of running timer independently of where it is
 `bold '*'` `green '--seconds'`   - show time in seconds
 `bold '*'` `green '-s|--short'`  - show time in short format (hh:mm:ss)
 `bold '*'` `green '--no-label'`  - hide `green [on]`/`red [off]` status label
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local current_dir=$(pwd -P)
    while (( $# )); do
        case $1 in
            -g|--global) local global=1;;
            --seconds)   local seconds=1;;
            -s|--short)  local short="--short";;
            --no-label)  local no_label=1;;
            *) err "Wrong option: $1" "See 'gtm help status'";;
        esac
        shift
    done
    if [ $global ]; then
        local current_repo=$(git config --global timetracker.repo)
        [ ! "$current_repo" ] && err "No running timers"
        cd "$current_repo"
        echo -n "`pwd`: `blue "[$(current_branch)]"` "
    fi

    local spent=$(current_time)
    if [ "$seconds" ]; then
        echo $spent && exit 0
    else
        echo -n "$(human_time $spent $short)"
    fi
    [ ! $no_label ] && echo -n $(on_status)
    echo
    [ "$current_repo" ] && cd "$current_dir"
    exit 0
}

function gtm_repo() {
    local help_msg="
`bold Usage`: `blue 'gtm repo'`

Show path to the repo of the current running timer (if any)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local current_repo=$(git config --global timetracker.repo)
    [ ! "$current_repo" ] && err "No running timers"
    echo "$current_repo"
}

function gtm_list() {
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    local current_branch=$(current_branch)
    [ $(start_date) ] && gtm_stop > /dev/null && gtm_start > /dev/null
    local lwidth=10
    local rwidth=0
    for branch in $branches; do
        (( ${#branch} > lwidth )) && lwidth=${#branch}
        local spent=$(human_time $(git config branch.$branch.spent))
        (( ${#spent} > rwidth )) && rwidth=${#spent}
    done
    lwidth=$(( lwidth + 2 )) # for [...]

    [ ! "$1" == "--no-header" ] && underline "$(bold "  #  %-${lwidth}s %${rwidth}s \n" "Task" "Time spent")"
    for branch in $branches; do
        local spent=$(human_time $(git config branch.$branch.spent))
        local issue=$(git config branch.$branch.issue)
        if [ "$branch" == "$current_branch" ]
        then
            [ $(start_date) ] && green "* " || red "* "
            yellow "%-2s " "$issue"
            blue "%-${lwidth}s " "[$branch]"
            printf  "%${rwidth}s"  "$spent"
            on_status
        else
            yellow "  %-2s " "$issue"
            blue "%-${lwidth}s " "[$branch]"
            printf  "%${rwidth}s"  "$spent"
        fi
        echo
    done
}

function full_name() {
    local br="$1" # branch name
    local acc="$2" # accumulated full name
    local base="$(git config branch.$br.base)"
    if [ ! "$base" ]; then
        git config branch.$br.base master
        base="master"
    fi
    if [ "$br" == "master" ]; then echo "$br:$acc"
    else full_name "$base" "$br:$acc"
    fi
}

function gtm_tree() {
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    # local branches=$(git config --get-regexp "^branch.*.base" | cut -d . -f 2)
    local current_branch=$(current_branch)
    local list=$(for branch in $branches; do echo $(full_name $branch); done | sort)
    for br in $list; do
        local cutbr=${br%:}
        echo -n $cutbr | sed 's/[^:]\+:\([^:]\+\)$/└── \1/g' | sed 's/[^:]\+:/    /g'
        [ "${cutbr##*:}" == "$(current_branch)" ] && echo " *" || echo
    done
}

function gtm_summary() {
    local alltimes=$(git log --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')
    local allusers=$(git log --format="%ae" | sort | uniq)
    local commits=$((`git log --oneline | wc -l`))
    local timed_commits=$((`git log --format="%N"  | grep "Time-spent:" | wc -l`))
    local percent=$(( $timed_commits * 100 / $commits ))
    echo "$timed_commits of $commits commits have time information ($percent%)"

    echo -n "Total time spent by authors in branch "
    blue "[$(current_branch)]\n"
    for author in $allusers; do
        local dedication=$(user_time_dedication $author)
        [ $dedication != 0 ] && printf " %-39s %s\n" "$author" "$(human_time $dedication)"
    done

    local total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done
    printf "\n%-40s %s\n" "Total time spent in this branch" "$(human_time $total)"
}

function gtm_report() {
    local help_msg="
`bold Usage`: `blue 'gtm report'` `green '[<options>]'` `green '[<git log options>]'`

Shows list of commits which have time information. Optional flags are
 `bold '*'` `green '-w|--week'`   - use particular week of this year (1..53)
 `bold '*'` `green '-f|--format'` - format of each line in the list with a placeholder for the time info ('_time_' or '_human_time_')
 `bold '*'` `green '-t|--total'`  - format of the total line (set it to space if you don't want it at all)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local git_args=""
    while (( $# )); do
        case $1 in
            -w|--week)
                [[ "$2" =~ [^0-9] ]] || (( $2 < 1 )) || (( $2 > 53 )) && \
                    err "Wrong argument for $1: should be a week number (1..53)" "See 'gtm help report'"
                local current_week=$(( $(date +%W) + 1 ))
                (( $2 > $current_week )) && err "It's not a fortune teller, current week is $current_week ($(monday $current_week) - $(sunday $current_week))"
                local mon=$(date -d "$(monday $2) -1 day" +%F)
                local sun=$(sunday $2)
                git_args="$git_args --since=$mon --until=$sun"
                shift
                ;;
            -f|--format)
                [ ! "$2" ] && err "Need an argument for $1: format with placeholder for time" "See 'gtm help report'"
                local format=$2
                shift
                ;;
            -t|--total)
                local total_line=$2
                shift
                ;;
            *)
                git_args="$git_args $1"
                ;;
        esac
        shift
    done
    # defaults
    local format=${format:-" * [%h] _time_ - %s"}
    local offset=${format%%[^ ]*}
    local total_line="${total_line:-${offset}"In total: _human_time_"}"

    local total=0
    local hashes=($(git --no-pager log --format="%H" --reverse $git_args))
    for h in ${hashes[@]}; do
        local t=$(git --no-pager notes --ref=refs/notes/timetracker show $h 2> /dev/null \
            | sed 's/^ *[^0-9]*\([0-9]\+\) *$/\1/')
        t=${t// /}
        # if it's not empty
        if [ "$t" ]; then
            fmt=${format/_human_time_/$(human_time $t)}
            fmt=${fmt/_time_/$(human_time $t --short)}
            [ "${fmt// /}" ] && git --no-pager show --format="$fmt" $h | head -1
            # [[ "$t" =~ [^0-9] ]] && err "$(pwd): $h"
            total=$(( $total + $t ))
        fi
    done
    if [ "${total_line// /}" ] && (( $total > 0 )); then
        local pre="${total_line/_human_time_/$(human_time $total)}"
        echo "${pre/_time_/$(human_time $total --short)}"
    fi

}

function gtm_weekly_report() {
    local help_msg="
`bold Usage`: `blue 'gtm weekly-report'` `green '[<first week>] [<last week>]'` `green '--projects <file>'` `green '[<git log options>]'`

Shows time reports (as `blue 'gtm report'`) grouped by weeks for a set of projects. You can set a configuration for the report with the following parameter:
 `bold '*'` `green '--projects <file>'` - projects configuration file

This projects mapping file is supposed to be a simple bash script, defining
 * `green prefix` string — path prefix of your local repositories;
 * `green project` dispatch function — which takes project key and returns a string, that has project name (title) as the first row and the list of repositories as the following rows;
 * `green projects` list — list of projects keys;

This file can also redefine format options: `green header`, `green week_format`, `green project_format`, `green repo_format`, `green commit_format`, `green total_format`.
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac


    week=$(( $(date +%W) + 1 ))
    [[ "$1" =~ [0-9]+ ]] && week=$1 && shift

    until_week=$week
    [[ "$1" =~ [0-9]+ ]] && until_week=$1 && shift

    # defaults
    header='# Weekly time records report \n\n'
    week_format='## %s \n\n'
    project_format='### %s \n\n'
    repo_format='#. _repo_ \n'
    commit_format='    + `[%h]` `_time_` — %s'
    total_format='\n    In total: _human_time_\n'


    # file with projects map and format options
    file=""
    [[ "$1" =~ --projects ]] && file=${2:?"Expected projects map file!"} && shift 2
    source "$file"
    (( $? != 0 )) && err "Failed to source '$file' script" ""


    function list() {
        local week=$1
        shift
        local mon=$(date -d "`monday $week`" +%d.%m.%Y)
        local sun=$(date -d "`sunday $week`" +%d.%m.%Y)

        printf "$week_format" "Week $week ($mon — $sun)"

        for project_id in ${projects[@]}; do
            local project_list=( $(project $project_id) )
            local project=${project_list[0]//_/ }
            local repos=${project_list[@]:1}
            local repo_data=""

            for repo in ${repos[@]}; do
                cd "$prefix/$repo"
                local commits=$(gtm report -f "$commit_format" -t "$total_format" -w $week "$@")
                repo=${repo_format//_repo_/"$repo"}
                [ "$commits" ] && repo_data="${repo_data}${repo}${commits}\n"
            done

            if [ "$repo_data" ]; then
                printf "$project_format" "$project"
                echo -e "$repo_data"
            fi
        done
    }

    local starting_point=$(pwd)

    echo -e "$header"

    until (( $week > $until_week )); do
        list $week "$@"
        week=$(( week + 1 ))
    done

    cd $starting_point

}

# parses [+-]minutes or [+-]hours:minutes or [+-]hours:minutes:seconds and returns seconds
function parse_time() {
    local t=$1
    local sign=1
    local h=0
    local m=0
    local s=0
    [[ $t =~ ^\+ ]] && t=${t:1}
    [[ $t =~ ^- ]] && sign=-1 && t=${t:1}

    if [[ $t =~ ^[0-9]+:[0-9]+:[0-9]+$ ]]; then
        h=${t%%:*} # [h]: m : s
        m=${t#*:}  #  h :[m : s]
        s=${m#*:}  #      m :[s]
        m=${m%:*}  #     [m]: s
    elif [[ $t =~ ^[0-9]+:[0-9]+$ ]]; then
        h=${t%:*}
        m=${t#*:}
    elif [[ $t =~ ^[0-9]+$ ]]; then
        m=$t
    else
        err "Wrong time format"
    fi
    t=$(( h * 3600 + m * 60 + s ))
    echo $(( sign * t ))
}

function gtm_set() {
    local help_msg="
`bold Usage`: `blue 'gtm'` `green '<[+-]time>'`

Sets, adds (with +) or subtracts (with -) given amount of time (without changing running state of the timer)
`green '<time>'` may be in one of the following formats:
 `bold '*'` `green 'hours:minutes:seconds'`
 `bold '*'` `green 'hours:minutes'`
 `bold '*'` `green '      minutes'`
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local t=$(parse_time $1)
    [[ $t =~ Wrong ]] && err "Wrong time format" "See 'gtm help set'"
    if [[ $1 =~ ^[+-] ]]; then
        spent_set $(current_time)
        [ $(start_date) ] && start_from_now
        t=$(( $(spent_get) + $t ))
        local ht=$(human_time $t --short)
        (( $t < 0 )) && err "Negative time: -${ht##* }"
        spent_set $t
    else
        spent_set $t
        [ $(start_date) ] && start_from_now
    fi
}

function gtm_add() {
    local help_msg="
`bold Usage`: `blue 'gtm add'` `green '[-]<minutes>'` or `blue 'gtm add'` `green '[-]<hours>:<minutes>'`

Adds or substracts time (without changing timer running state)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local t=$(parse_time $1)
    [[ $t =~ Wrong ]] && err "Wrong time format" "See 'gtm help set'"
    spent_set $(( $(spent_get) + $t ))
}

function gtm_note() {
    if [[ "$1" =~ ^- ]] || (( $# == 0 )); then
        git commit --allow-empty "$@"
    else
        git commit --allow-empty -m "$@"
    fi
}

function gtm_amend() {
    local help_msg="
`bold Usage`: `blue 'gtm amend'` `green '[<commit_sha>]'`

Sets currently spent time to the commit with given sha (HEAD by default)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    sha=${1:-"HEAD"}
    running=$(start_date)
    gtm_stop > /dev/null
    spent=$(spent_get)

    if [ $spent ]; then
        git notes --ref timetracker add -f -m "Time-spent: $spent" $sha
        echo "Time spent: $(human_time $spent)"
        spent_set 0
    fi
    [ $running ] && gtm_start > /dev/null
}

function gtm_push() {
    local help_msg="
`bold Usage`: `blue 'gtm push [--tag|-t]'`

* pushes timetracker notes,
* then pushes current branch (setting upstream if needed)
* then tags (with `green --tag` option)
* connects this branch to the issue if needed (see `blue 'gtm help connect'`)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    echo "Pulling timetracker notes: "
    git fetch origin "+refs/notes/timetracker:refs/notes/remotes/origin/timetracker"
    gtm merge

    echo "Pushing timetracker notes: "
    git push
    failed $? "Some issues with pushing timetracker notes.$trst Maybe you should first run '`blue 'git pull'`' (+ '`blue 'gtm merge'`' if needed)"

    echo
    echo "Pushing current branch: "
    local set_upstream=""
    local upstream=$(git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD))
    [ ! "$upstream" ] && set_upstream="-u"
    git push $set_upstream origin $(current_branch)

    if [ "$1" == "--tag" ] || [ "$1" == "-t" ]; then
        echo
        echo "Pushing tags:"
        git push --tag
    fi

    if [ ! "$(current_branch)" == "master" ]; then
        echo
        local issue=$(git config branch.$(current_branch).issue)
        if [ ! "$issue" ]; then
            echo $(red "This branch is not connected to any issue. Try `blue 'gtm connect -i <issue>'`")
        else
            local connected=$(git config branch.$(current_branch).connected)
            if [ ! "$connected" == "true" ]; then
                echo "Connecting the branch with issue `yellow \#$issue`"
                gtm_task_connect
            fi
        fi
    fi
}

function gtm_steal() {
    case $1 in
        -i)
            local issue=$2
            [ ! "$issue" ] && gtm_list && err "Choose task number, from which you want to steal time"
            local branch=$(git config --get-regexp "branch.*.issue" | grep " $issue$")
            branch=${branch#branch.}
            branch=${branch%.issue $issue}
            [ ! "$branch" ] && gtm_list && err "No task #$issue. Create a new one or choose from existing"
        ;;
        -b)
            local branch=$2
        ;;
    esac
    local branch=${branch:-master}
    local timer=$(spent_get $branch)
    spent_set $(( $(spent_get) + $timer ))
    spent_set 0 $branch
    green "Stolen time from branch "; blue "[$branch]"; echo ": `human_time $timer`"
}

function gtm_undo() {
    local n=${1:-1}
    local timers=$(git log -$n --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')
    echo `green "You are going to undo following commits:"`
    echo
    gtm log -$n | cat
    confirm
    git reset --soft HEAD~$n

    local total=0
    for t in $timers; do
        total=$(( $total + $t ))
    done
    spent_set $(( $(spent_get) + $total ))
    if (( $n == 1 )); then
        green "Undone last commit and returned it's time: "; echo "`human_time $total`"
    else
        green "Undone $n commits and returned their time: "; echo "`human_time $total`"
    fi
}

function gtm_task_new() {
    local help_msg="
`bold Usage`: `blue 'gtm task'` `green '<branch_name> <-i number | -m title> [issue_options]'`

Creates a task combining given branch and issue:

 `bold '*'` `green '<branch_name>'` can be an existing branch (use '`green -`' for current) or a name for new branch

 `bold '*'` If you want to bind task to an existing issue, use
     `green '-i <number>'`
   else create a new one:
     `green '-m <issue_title>'`
   it will be assigned to you and it will get labels retrieved from the branch name prefix,
   i.e. if branch name is 'feature/topic/name', labels are 'feature' and 'topic'

   `green '[issue_options]'` are any options accepted by 'ghi open' (see 'ghi help open')
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local name=$1
    [ ! "$name" ] && err "Need a branch name for creating task (use '-' for current branch)" "See 'gtm help task'"
    [ "$name" == "-" ] && name=$(current_branch)

    local issue_flag=$2
    [ "$issue_flag" != "-i" ] && [ "$issue_flag" != "-m" ] && err "Wrong issue flag: $issue_flag" "See 'gtm help task'"
    local issue=$3

    local prefix=${name%/*}
    local labels=""
    # if prefix was not empty
    [ "$prefix" != "$name" ] && labels=" -L "${prefix//\// -L }

    # info and confirmation
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    local exists=$(echo $branches | grep "$name")
    if [ "$exists" ]; then
        local step1="`bold 1.` Use an existing branch `blue [$name]`"
    else
        local base=$(current_branch)
        local step1="`bold 1.` Create a new branch `blue [$name]` from `red [$base]`"
    fi
    case $issue_flag in
        -i)
            local step2="`bold 2.` Bind the task to an existing issue `yellow \#$issue`:"
        ;;
        -m)
            local step2="`bold 2.` Bind the task to a new issue "$(yellow "\"$issue\"")
            [ "$labels" ] && step2=$step2" with tags: ${prefix//\//, }"
        ;;
    esac
    echo $step1
    echo $step2
    [ "$issue_flag" == "-i" ] && ghi show $issue
    confirm

    [ "$exists" ] && git checkout $name &> /dev/null || git checkout -b $name &> /dev/null
    git config branch.$name.base ${base:master}

    # issue binding
    case $issue_flag in
        -i)
            git config branch.$name.issue $issue
            echo "`green Issue` `yellow \#$issue` `green "is assigned to the task"`"
        ;;
        -m)
            local ghi_out=$(ghi open  --claim  $labels  "${@:2}")
            local number=$(echo $ghi_out | grep '#' | sed 's/^#\([0-9]*\):.*$/\1/')
            if [ "$number" ]; then
                git config branch.$name.issue $number
                ghi show $number
                echo "`green Issue` `yellow \#$number` `green "is assigned to the task"`"
            fi
        ;;
    esac
    gtm_list
}

function gtm_task_connect() {
    local help_msg="
`bold Usage`: `blue 'gtm connect'` `green '[-t <task_branch>] [-b <base_branch>] [-i <issue_number>]'`

Connects task branch with and issue and transforms it to pull-request
(to merge it into base branch) if possible (i.e. if there are any pushed commits).

By default
 `bold '*'` `green '<task_branch>'` is current branch
 `bold '*'` `green '<base_branch>'` is the branch from which the task was created
 `bold '*'` `green '<issue_number>'` is issue assigned to the <task_branch> (if it exists)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    while (( $# )); do
        case $1 in
            -t)
                [ ! $2 ] && err "Need an argument for -t: task that you want to connect" "See 'gtm help connect'"
                local task=$2
                [ ! "$(echo $branches | grep "$task")" ] && err "Task [$task] doesn't exist:" "$(gtm_list)"
                ;;
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name" "See 'gtm help connect'"
                local base=$2
                [ ! "$(echo $branches | grep "$base")" ] && err "Branch [$base] doesn't exist:" "$(git branch)"
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number" "See 'gtm help connect'"
                local issue=$2
                ;;
            *)
                err "Wrong options: $*" "See 'gtm help connect'"
                ;;
        esac
        shift 2
    done
    local task=${task:-$(current_branch)}
    local base=${base:-$(git config branch.$task.base)}
    base=${base:-master}
    local issue=${issue:-$(git config branch.$task.issue)}
    if [ -z "$issue" ]; then
        red "Please provide issue number with -i option:\n"
        ghi list && exit 1
    fi

    git config branch.$task.issue $issue
    echo "`green Issue` `yellow \#$issue` `green "is assigned to the task"` `blue [$task]`"
    local check=$(ghi show $issue | grep "^↑$issue:")
    if [ "$check" ]; then
        echo "This task is already connected to a pull-request"
        git config branch.$task.connected true
    else
        ghi edit --head $task --base $base $issue
        if (( $? != 0 )); then
            red "Couldn't transform issue to pull-request. "
            echo "Either it's already a pull-request, or you didn't push anything yet. Try `blue 'gtm push'`."
        else
            git config branch.$task.connected true
        fi
    fi
}

function gtm_task_close() {
    local help_msg="
`bold Usage`: `blue 'gtm close'` `green '[-b <base_branch>] [-i <issue_number>]'`

Closes current task in several steps:

`bold 1.` Try to merge task branch into base branch
`bold 2.` Push task branch
`bold 3.` Push base branch and timetracker notes (it will close the issue)
`bold 4.` Archive task branch and move the time remained on it to the base branch

By default `green '<base_branch>'` is master and `green '<issue_number>'` is the issue assigned to the current task
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local task=$(current_branch)
    [ "$task" == "master" ] && err "You are on [master] branch. Swith to the task, that you want to close"

    local dirty=$(git status -s)
    [ "$dirty" ] && err "You have uncommited changes. Please, commit them first"

    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    while (( $# )); do
        case $1 in
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name" "See 'gtm help close'"
                local base=$2
                [ ! "$(echo $branches | grep "$base")" ] && err "Branch [$base] doesn't exist:" "$(git branch)"
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number" "See 'gtm help close'"
                local issue=$2
                git config branch.$task.issue $issue
                ;;
            *)
                err "Wrong options: $*" "See 'gtm help close'"
                ;;
        esac
        shift 2
    done
    local base=${base:-$(git config branch.$task.base)}
    base=${base:-master}
    local issue=${issue:-$(git config branch.$task.issue)}
    if [ ! "$issue" ]; then
        red "Task is not connected to any issue."
        echo " Choose one of existing and use '-i <number>' option or create a new one"
        ghi list && exit 1
    fi
    local step1="`bold 1.` Push `blue [$task]` branch with timetracker notes"
    local step2="`bold 2.` Try to merge `blue [$task]` into `green [$base]`"
    local step3="`bold 3.` Push `green [$base]` branch (it will close issue `yellow \#${issue}`)"
    local step4="`bold 4.` Archive `blue [$task]` task and move the time remained on it to `green [$base]`"
    overview "$step1" "$step2" "$step3" "$step4"
    echo
    echo "$step1"
    gtm push
    failed $? "Couldn't push [$task] branch to remote origin"
    echo
    echo "$step2"
    git checkout $base
    git merge --no-ff $task
    (( $? != 0 )) && err "Couldn't merge branch [$task] into [$base]" "If there are merge conflicts, resolve them and then do 'git checkout -' and 'gtm close' again"
    echo
    echo "$step3"
    git push origin $base
    failed $? "Couldn't push [$base] branch to remote origin"
    echo
    echo "$step4"
    spent_set $(( $(spent_get) + $(git config branch.$task.spent) ))
    # git checkout $base > /dev/null
    git tag "archive/$task" "$task"
    git branch -d $task
    git push --tag
    git push origin --delete $task
    failed $? "Couldn't delete branch [$task]"
    echo
    ghi show $issue
}

function gtm_task_switch() {
    local help_msg="
`bold Usage`: `blue 'gtm switch'` `green '<issue_number>'`

Switches to the task with given issue number (just does 'git checkout' to the corresponding branch)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local issue=$1
    [ ! "$issue" ] && err "Choose task you want to switch to and use it's issue number or '-' for [master] branch:" "$(gtm_list)"
    [ "$issue" == "-" ] && git checkout master && exit

    local task=$(git config --get-regexp "branch.*.issue" | grep " $issue$")
    [ ! "$task" ] && err "No task #$issue. Create a new one or choose from existing:" "$(gtm_list)"
    local branch=${task%.issue*}
    git checkout ${branch#branch.}
}

function gtm_task_info() {
    local help_msg="
`bold Usage`: `blue 'gtm info'` `green '[options]'`

Shows issue which is bound to the current task. See possible options in `blue 'ghi help show'`.
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    echo "Task `blue "[$(current_branch)]"` from `red "[$(git config branch.$(current_branch).base)]"`: `gtm_status`"
    echo
    local issue=$(git config branch.$(current_branch).issue)
    [ ! "$issue" ] && err "No issue is bound to the task" "See 'gtm help connect'"
    ghi show $issue "$@"
}

function gtm_task_comment() {
    local help_msg="
`bold Usage`: `blue 'gtm comment'` `green '[options]'`

Opens default editor to comment the issue, bound to the current task. See possible options in `blue 'ghi help comment'`.
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    echo "Task `blue "[$(current_branch)]"`: `gtm_status`"
    echo
    local issue=$(git config branch.$(current_branch).issue)
    [ ! "$issue" ] && err "No issue is bound to the task" "See 'gtm help connect'"
    ghi comment $issue "$@"
}

function gtm_addhooks() {
    [ ! "$(gitdir)" ] && err "It's not a git root directory!"
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    [ ! "$branches" ] && err "Looks like an empty repository. Make an init commit and try again."

    local hooksdir="$(gitdir)/hooks"
    [ ! -d $hooksdir ] && mkdir $hooksdir

    local pre_commit="$hooksdir/pre-commit"
    pre_commit_hook > $pre_commit
    chmod +x $pre_commit

    local post_commit="$hooksdir/post-commit"
    post_commit_hook > $post_commit
    chmod +x $post_commit

    local post_merge="$hooksdir/post-merge"
    post_merge_hook > $post_merge
    chmod +x $post_merge

    local post_checkout="$hooksdir/post-checkout"
    post_checkout_hook > $post_checkout
    chmod +x $post_checkout

    green "Hooks created: "
    echo "pre-commit, post-commit, post-merge, post-checkout"
}
function gtm_config() {
    local remote=${1:-origin}
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    [ ! "$branches" ] && err "Looks like an empty repository" "Make an init commit and try again."

    local push="refs/notes/timetracker:refs/notes/timetracker"
    local exists=$(git config --get-all remote.$remote.push | grep "$push")
    [ ! "$exists" ] && git config --add remote.$remote.push $push

    local fetch="+refs/notes/timetracker:refs/notes/remotes/$remote/timetracker"
    local exists=$(git config --get-all remote.$remote.fetch | grep "$fetch")
    [ ! "$exists" ] && git config --add remote.$remote.fetch $fetch

    git config notes.rewriteRef "refs/notes/timetracker"
    git config notes.displayRef "refs/notes/timetracker"
    git config timetracker.branch $(current_branch)

    for branch in $branches; do
        spent_get $branch &> /dev/null
    done

    green "Git task manager is configured\n"
    echo "Trying to fetch and merge remote timetracker notes..."
    git fetch origin $fetch
    gtm merge
}

#############

if (( $# == 0 )); then
    [ ! $(gitdir) ] && show_help && exit 0
    gtm_status && exit 0
fi

subcommand=$1
shift

# global commands
case $subcommand in
    stop|-p)
        gtm_stop "$@"
        exit 0
    ;;
    usage|-h|--help|help)
        show_help "$@"
        exit 0
    ;;
    version|-v|--version)
        echo "gtm v$VERSION - git task/time manager (c) Alexey Alekhin"
        exit 0
    ;;
    prompt-status)
        if [ "$(git config timetracker.branch)" ]; then
            on_status && echo -n " " && human_time $(current_time) --short
        else
            printf "%15s" $(date +%T)
        fi
        exit 0
    ;;
    repo)
        gtm_repo
        exit 0
    ;;
esac

# rest of the commands work only in a git repository
if [ ! $(gitdir) ] && [ "$1" != "--help" ] && [ "$1" != "-h" ]; then
    err "It's not a git root directory!"
fi
case $subcommand in
    start)
        gtm_start "$@"
    ;;
    status)
        gtm_status "$@"
    ;;
    +|-)
        gtm_set "${subcommand}$@"
        gtm_status
    ;;
    list)
        gtm_list "$@"
    ;;
    tree)
        gtm_tree "$@"
    ;;
    undo)
        gtm_undo "$@"
    ;;
    steal)
        gtm_steal "$@"
    ;;
    amend)
        gtm_amend "$@"
    ;;
    delete)
        git notes --ref timetracker remove ${1:-HEAD}
    ;;
    note)
        gtm_note "$@"
    ;;
    summary)
        gtm_summary "$@"
    ;;
    report)
        gtm_report "$@"
    ;;
    weekly-report)
        gtm_weekly_report "$@"
    ;;
    log)
        git log --color "$@" | sed "s/Time-spent: \([0-9]\+\)/gtm human-time \1/e" | less -R
    ;;
    human-time)
        human_time "$@"
    ;;
    addhooks)
        gtm_addhooks
    ;;
    config)
        gtm_config
    ;;
    init)
        gtm_addhooks
        gtm_config
    ;;
    merge)
        git notes --ref timetracker merge "refs/notes/remotes/${1:-origin}/timetracker"
    ;;
    push)
        gtm_push "$@"
    ;;
    addf)
        gtm_addf "$@"
    ;;
    commit)
        gtm_commit
    ;;
# Tasks:
    task)
        gtm_task_new "$@"
    ;;
    close)
        gtm_task_close "$@"
    ;;
    switch)
        gtm_task_switch "$@"
    ;;
    connect)
        gtm_task_connect "$@"
    ;;
    info)
        gtm_task_info "$@"
    ;;
    comment)
        gtm_task_comment "$@"
    ;;
    *)
        t=$(parse_time $subcommand)
        if [[ ! $t =~ Wrong ]]; then
            gtm_set $subcommand
            gtm_status
        else
            red "Wrong subcommand: "; echo "$subcommand"
            show_help
        fi
    ;;
esac
